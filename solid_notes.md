SOLID

1️⃣ S => Single responsibility 
- class should solve only one problem

مثلا لو عندى مستشفى المستشفى دى فيها دكتور واحد بيعالج كل الامراض ذى البرد ، الكلي ، القلب وغيره 
هل دا صح ؟؟
لا غلط لو الدكتور غاب المستشفى كلها مش هتشتغل 
طب لو جبنا دكاتره كتير كل دكتور بيعالج مرض واحد كده الصح 
فلو دكتور فيهم غاب عادى الباقى شغال 
دى نفس الفكره كل كلاس بيقوم بحاجه واحده بس .

-ال single responsibility كل كلاس له مسئوليه واحده يعني مش لازم ميثود واحده .
يعنى مثلا لو عندنا كلاس اسمه BasicAnimalShare كده ممكن يكون فيه داله للمشى وداله للأكل علشان دا كده مسؤليه واحده او دول حسب اسم الفانكشن حاجه واحده .

⚡ وفى مثال فى interface segregation code يوضح الجزء دا
  
2️⃣ O => Open closed principle 
- class should Open for extension closed for modification

مثلا لو عندى كلاس اسمه AreaCalc وفيه ميثود بتجيب مساحه شكل معين اسمها getArea
وعملنا فيها لو الشكل دا مثلث رجع معادله معينه ولو الشكل دا مربع رجع معادله معينه تمام 
كده بقى لو عاوزه احسب مساحه مستطيل هضطر اروح اعدل ف الكود واضيف لو الشكل مستطيل رجع معادله دا كده غلط ❌ مينفعش اعدل ف الكود فلازم من الأول خالص اعمل abstract  كلاس اسمه AreaCalc وفيه abstract ميثود اسمها getArea واروح اعمل كلاس للمثلث واخليه يورث من كلاس ال AreaCalc واعمل فيه override للميثود ال في كلاس ال AreaCalc واضيف المعادله 
وبكدا كل ما أعوذ احسب مساحه شكل اعمل كلاس جديد واعمله inheritance بدل ما اعدل ف الكود
 
3️⃣ L => liskov's substitution
- لو الأب  مش موجود الابن هيقوم بالدور مكانه
- مثلا لو عندنا قهوه بيشتغل فيها الأب وابنه وفى زبون ايجى طلب قهوه الأب دايما كان بيعملهاله بس المره دى الأب مش موجود فطلب القهوه من الابن الابن رد عليه قاله معلش مش بعرف اعمل قهوه خد شاى اهو كده غلط ❌ 
لازم الابن يكون بيعرف يعمل قهوه ويروح يقدمها للزبون ذى ما الأب كان بيعمل
- مثال تانى مثلا لو عندى كلاس اسمه Bird فيه ميثود اسمها eat وعندنا كلاس تانى اسمه FlyingBirds وفيه ميثود اسمها fly وكمان بيورث من كلاس ال Bird
كده لو عملنا كلاس اسمه Swan بيورث من كلاس FlyingBird لازم الكلاس ال اسمه Swan دا يكون بيعرف ياكل وبيعرف يطير علشان هيورث الاكل ( ال FlyingBirds ورثاه من ال bird ) وهيورث الطيران ال في كلاس ال FlyingBird نفسه

4️⃣ I => Interface segregation 
- بقسم ال interface الي interfaces صغيره محدده
- دى بقسم ال interface بحيث كل واحده تحتوي علي الميثود المناسبه وال ينفعو مع بعض فقط 
ذى مثال : كل الحيوانات بتاكل وتشرب وفى منهم بيمشى ومنهم بيطير خلاص هنعمل انترفيس فيها انها تاكل وتشرب فقط وهنعمل انترفيس للمشى فقط ونعمل انترفيس تانيه للطيران فقط كده قسمنا الانترفيس حسب الحيوانات محتاجه ايه

5️⃣ D => Dependency Inversion

- ال high level لا يعتمد علي ال low level بل هما الاتنين يعتمدون علي abstract class
- مثلا لو عندى كلاس فيه داله جمع وكلاس تانى فيه داله طرح وكلاس تالت بعمل object من الكلاسين دول وبستخدمهم فيه كده الكلاس التالت هو ال high class والكلاسين الاولانين دول low class فكده الكلاس التالت ال high بيعتمد علي ال low class الاولانين كده غلط ❌ علشان لو حصل تعديل فيهم هيأثر علي الكلاس ال high 
فلازم بقى نعمل abstract  class نسميه CalcOperation مثلا ونخلي ال low level class يورثو منه

![solid](images/solid.jpeg)

- [READ](https://dev.to/lionnelt/solid-principles-in-dartflutter-2g21)
- [READ](https://medium.com/nerd-for-tech/solid-principles-in-a-flutter-32eaf7218476)
- [YOYRUBE](https://youtube.com/playlist?list=PLYOFAmhj26B_WvbghzzHTkokHmx7G-AEr&si=IMUFaguEheT0ZhcY)
